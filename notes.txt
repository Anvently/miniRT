

- generate rays for each pixel
	- for each objects :
		- check collision
		- take first inter
			- bounce ray
			- for each light
				- check if ray within light cone
				- check if no collision to light
		- calculate color of pixel.


PARSING

- C [origin] [orientation] [fov]
- A [ratio] [color]
- L [origin] [ratio] [color]
- SP [origin] [diameter] [texture] [ka] [kd] [ks] [kr] [iref] [p] [r]
- PL [origin] [orientation] [texture] [ka] [kd] [ks] [kr] [iref] [p] [r]
- CY [origin] [orientation] [diameter] [height] [texture] [ka] [kd] [ks] [kr] [iref] [p] [r]
- CO [center of base] [orientation] [radius] [height] [texture] [ka] [kd] [ks] [kr] [iref] [p] [r]
- move [target:target] [type:RTS] [value:orientation] [speed:speed]

texture :
Solid color : [S:color]
Dame : [D:color1:color2:resolution], resolution = nbr of vertical cells/unit
Image : [I:path], can must be within "" if it contains spaces.

ka = ambiant light reflexion constant (0 <= ka <= 1)
kd = diffuse light reflexion constant (0 <= kd <= 1)
ks = specular light reflexion constant (0 <= ks <= 1)
kr = reflexion constant (0 <= kr <= 1)
iref = refraction factor
p = portion of plastic reflexion on surface (0 <= p <= 1)
r = roughness of material constant (1 <= r <= INFINITY)

Move:
target
	- > 0: id of target
	- 0: every objects
type
	- R: rotation
	- Rs: self rotation for sphere
	- T: translation
	- S: scale
orientation
	- for rotation : angle_x,angle_y,angle_z
	- for translation : value_x,value_y,value_z
	- for scale : value_x,value_y,value_z
speed
	- nbr of move / sec
	- ex: for 30 FPS and speed=1, all value are to be multiplied by 1/30 at
		each rendering.
	- ex: for render_time = 1.5s, value = 1.5/1 * speed

typ

https://www.math3d.org/rnFtwewET